#' Principal Component Analysis
#' @export
#' @description This function is used to perform Principal Component Analysis (PCA).
#' @param X Numeric input matrix with each row representing an observation and each column a metabolic variable.
#' @param pc Desired number of principal components.
#' @param scale Desired scaling method: \code{None}, \code{UV} (unit variance) or \code{Pareto} (Pareto scaling).
#' #' @param center Logical indicating if data should be mean centered.
#' @param method Algorithm for computing PCA. NIPALS is default and usually fine, see Details for other methods.
#' @details Other PCA algorithms build on the pcaMethods R package and include: 'svd', 'ppca', 'svdImpute', 'robustPca', 'nlpca'. For complete list of available methods see \code{?pcaMethods::pca} documentation.
#' @references Geladi, P and Kowalski, B.R. (1986), Partial least squares and regression: a tutorial. \emph{Analytica Chimica Acta}, 185, 1-17.
#' @return This function returns a \emph{PCA_metabom8} S4 object.
#' @author Torben Kimhofer \email{torben.kimhofer@@murdoch.edu.au}
#' @importFrom pcaMethods pca
#' @family NMR ++
#' @examples
#' data(covid)
#' model=pca(X)
#' plotscores(model, an=list(Class=an$type, Clinic=an$hospital, id=1:nrow(an)), pc=c(1,2))

pca <- function(X, pc = 2, scale = "UV", center = TRUE, method = "nipals") {

  {
    if(is.data.frame(X)) X=as.matrix(X)
    pc_max=min(c(ncol(X), min(nrow(X))))
    if(pc>=pc_max){ message(paste('Too many number of components, setting pc to', pc_max)); pc=pc_max }
    if(!is.logical(center)){stop('Check center parameter argument!')}
    sc_num<-switch(scale,
                   'None'={0},
                   'UV'={1},
                   'Pareto'={2})
    if(is.null(sc_num)){stop('Check scale parameter argument!')}

    x_check<-.checkXclassNas(X)
    msd_x<-.sdRcpp(X)
    XcsTot<-.scaleMatRcpp(X, 0:(nrow(X)-1), center=TRUE, scale_type = sc_num)[[1]]
  }
  if (method == "nipals") {
    res <- list()
    for (i in seq_len(pc)) {
      if (i == 1) {
        res[[i]] <- .nipPcaCompRcpp(XcsTot)
      } else (res[[i]] <- .nipPcaCompRcpp(X = res[[i - 1]][[1]]))
    }

    Tpc <- vapply(res, "[[", 2, FUN.VALUE = X[,1])
    Ppc <- vapply(res, "[[", 3, FUN.VALUE = X[1,])
    # total.var<-sum(diag(cov(X))) #Calculate total variance in
    tssx<-.tssRcpp(XcsTot)
    #Calculate proportion of variance explained and cumulative
    ss_comp <- rep(NA, ncol(Tpc))
    for (i in seq_len(ncol(Tpc))) {
      ss_comp[i] <- .tssRcpp(Tpc[, i] %o% Ppc[, i]) / tssx
    }

    pars <- list(
      'center'= center,
      'scale'= scale,
      'nPC'= pc,
      'R2' = ss_comp,
      'tssx'= tssx
    )

    mod_pca <- new("PCA_metabom8", type ='NIPALS', t = Tpc, p = Ppc, nPC = pc, X_mean=msd_x[[1]], X_sd=msd_x[[2]], Parameters=pars,  X=X )
  } else {

    mod <- pcaMethods::pca(X, nPcs = pc, scale = "none", center = FALSE, method = method)
    r2 <- mod@R2cum
    r2[-1]=diff(mod@R2cum)
    tssx<-.tssRcpp(XcsTot)
    pars=list(
      'center'= center,
      'scale'= scale,
      'nPC'= pc,
      'R2' = r2,
      'tssx'= tssx
    )

    mod_pca <-  new("PCA_metabom8", type =method, t = mod@scores, p = mod@loadings, nPC = pc, X_mean=msd_x[[1]], X_sd=msd_x[[2]], Parameters=pars,  X=X)
  }
  return(mod_pca)
}



